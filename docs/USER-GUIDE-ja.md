# ftime ユーザーガイド（ジュニアSE向け）

このガイドは、ftime を初めて使うジュニアSEが「何ができるツールか」「どの場面で役立つか」「どう操作すればよいか」を素早く理解し、日常業務に組み込めるようにすることを目的とします。仕様や設計の詳細は `docs/SPEC-ja.md` と `docs/ARCHITECTURE-ja.md` にありますが、本書では実務シナリオを中心に手順を示します。

---

## 1. ftime が解決する課題
- 直近に触ったファイルをすぐ見つけたい（IDEを開く前に作業再開ポイントを把握したい）。
- 「今日何を変更したか」を簡単に共有したい（デイリースクラムや振り返りで使う）。
- ログや成果物をパイプで別ツールに渡し、作業スクリプトの前段にしたい。
- 大量の履歴でターミナルが流れ過ぎるのを防ぎたい（History折り畳み・20件上限）。

## 2. 前提とセットアップ
- Rust開発環境がある場合: `cargo build --release` で `target/release/ftime` を生成。
- 依存は `clap`, `colored`, `chrono`, `is-terminal`, `anyhow` のみ。追加設定不要。
- PATHに追加する場合: `~/.local/bin` などにバイナリをコピーするだけで動作。

## 3. コマンドの基本形
```
ftime [OPTIONS] [PATH]
```
- PATH省略時はカレントディレクトリ。
- オプション:
  - `-a, --all` : History（7日より古い）を展開
  - `-H, --hidden` : 隠しファイルも表示
  - `-h, --help` : ヘルプ
  - `-V, --version` : バージョン
- 環境変数:
  - `NO_COLOR` : 色を無効化
  - `FTIME_FORCE_TTY` : パイプでもTTYスタイルを強制

## 4. 代表的ユースケース（シナリオ別解説）

### 4.1 朝イチの作業再開
**状況**: 前日に触ったコードをすぐ開きたい。  
**コマンド**: `ftime`  
**読み方**:  
- 「🔥 Active」に今日触ったばかりのファイルが並ぶ。  
- 「☕ Today」で日内の編集対象が把握できる。  
- Historyは折り畳まれノイズが少ない。  
**次のアクション例**: 一覧からファイル名をコピーしてエディタで開く、あるいは `fzf` で絞り込む。

### 4.2 前日までの変更をまとめたい（デイリースクラム用）
**状況**: チームに昨日の作業内容を共有したい。  
**コマンド**: `ftime -a`  
**ポイント**: Historyも表示されるので昨日のファイルがリストに出る。20件超の場合は `... and N more items` で件数把握だけ行い、詳細はパイプで見る。  
**補助**: `NO_COLOR=1 FTIME_FORCE_TTY=1 ftime -a > /tmp/today.txt` とするとログに貼れるプレーンなTTY書式で保存できる。

### 4.3 設定ファイルや隠しファイルを含めて確認したい
**状況**: `.env` や `.gitignore` などを更新したか確認したい。  
**コマンド**: `ftime -H` （必要に応じて `-a` 併用）  
**注意**: 情報量が増えるので必要時のみ。機密ファイルのパスが出力に含まれる点に留意。

### 4.4 パイプでファイル一覧を別ツールへ渡す
**状況**: 最近変更したファイルを `fzf` で選びたい、またはスクリプトで処理したい。  
**コマンド例**:  
```
ftime | fzf --with-nth=1 | cut -f1
```
- 非TTYなので全件タブ区切りで出る。`cut -f1` でパスだけ抽出できる。  
**応用**: `ftime | head -n 20 | xargs -r ls -l` でメタ情報を追加確認。

### 4.5 バグ調査の足がかりを作る
**状況**: 直近で触ったファイルから原因箇所を当たりたい。  
**コマンド**: `ftime -a -H | head -n 40`  
**狙い**: 隠し設定や古いログも含めて時系列で眺め、関係ありそうなファイルを早く絞る。  
**派生**: `ftime | grep '.log\t'` でログだけ抜き出す。

### 4.6 CIログで簡易サマリを出す
**状況**: CIジョブ内で「何をスキャンしたか」を残したい。  
**コマンド**: `NO_COLOR=1 ftime`  
**理由**: 色コードを混ぜず、ターミナル有無に依存しないログが得られる。TTYがない場合は自動的にタブ区切りになる。

### 4.7 クリーンアップ前の確認
**状況**: 古い成果物を掃除する前に最終更新日をざっと確認したい。  
**コマンド**: `ftime -a | grep '💤 History' -A25`  
**使い方**: History表示を確認し、最終更新日が古いファイルから削除候補を判断。削除自体は別コマンドで行う。

### 4.8 新規プロジェクトに入った直後
**状況**: ディレクトリ構造が分からない状態で何が最近触られているか知りたい。  
**コマンド**: `ftime -a -H`  
**メリット**: dotfileやスクリプトを含め、活発に更新されている領域が一目で分かる。探索の優先度付けに使える。

## 5. よく使うレシピ集
- 最新5件だけ確認: `ftime | head -n 5`
- パスだけ一覧: `ftime | cut -f1`
- TTYスタイルをテキストで保存: `NO_COLOR=1 FTIME_FORCE_TTY=1 ftime > /tmp/ftime.txt`
- ディレクトリのみ抽出（TTY強制を活用）: `FTIME_FORCE_TTY=1 ftime | grep '/  '`
- 7日以上前だけを見る（非TTY出力を利用）: `ftime | awk -F'\t' '$2 ~ /[0-9]{4}-[0-9]{2}-[0-9]{2}/ {print $0}'`

## 6. 出力の読み方（ジュニア向け補足）
- バケット順は常に「Active → Today → This Week → History」。同じファイルが複数バケットに出ることはない。
- TTYでは1バケット20件まで。`... and N more items` が出たら、そのバケットに20+N件あるという意味。
- シンボリックリンクは `name -> target` と表示され、解決できない場合は `<unresolved>` になる。
- 非TTY（パイプ）ではヘッダやアイコンは出ない。タブ区切り2列だけなのでスクリプト処理しやすい。

## 7. トラブルシュート
- **何も表示されない**: ディレクトリが空か、隠しファイルしかない可能性。`-H` を試す。空なら `No recent files found` が出る。
- **色が出ない**: `NO_COLOR` が設定されていないか確認。Windows旧端末ではANSI色非対応のことがある。
- **Historyが多すぎて見切れない**: 折り畳みのまま件数だけ確認し、パイプ出力で詳細を別途処理。
- **日付の区切りが想定と違う**: ローカルタイムゾーン基準。リモートやコンテナでTZが違う場合は環境変数`TZ`を合わせる。
- **パスにタブが混じる**: パイプ出力の区切りと衝突する。`tr '\t' ' '` で置換してから処理。

## 8. 典型的な1日の利用フロー（例）
1. **出社直後**: `ftime` で直近ファイルを確認 → 重点タスクを決める。  
2. **作業中**: 必要に応じて `ftime -H` で設定ファイルの変更もチェック。  
3. **デイリースクラム前**: `ftime -a > /tmp/today.txt` で共有用メモを作る。  
4. **バグ調査**: `ftime -a -H | head -n 40` で範囲を絞り、ログや設定を確認。  
5. **終業時**: `ftime -a` の結果を振り返り、翌日の着手箇所をメモ。

## 9. ジュニアSEへのおすすめ設定
- シェルエイリアスを用意: `alias fr='ftime -a -H'`（履歴と隠しファイルを常時見たい場合）。  
- CIでは `NO_COLOR=1` をデフォルトにしてログを読みやすくする。  
- fzf 連携を覚えるとファイルオープンが高速化する（例: `ftime | fzf --with-nth=1 | xargs -r code`）。

## 10. チェックリスト（使い方を覚えたか確認）
- [ ] バケットの意味と優先順を説明できる。  
- [ ] `-a` と `-H` の違いを説明できる。  
- [ ] TTYと非TTYで出力がどう変わるか言える。  
- [ ] NO_COLOR / FTIME_FORCE_TTY の効果を表で指させる。  
- [ ] パイプ出力を別ツールに渡す簡単な例を示せる。  

## 11. Q&A（短答）
- **Q: 再帰しないのはなぜ？**  
  A: 深さ1で速さとシンプルさを確保するため。大量ツリーでも即応答にする設計。
- **Q: 20件上限を変えたい**  
  A: 現行は固定。全件見たいときは非TTY出力（パイプ）を使う。
- **Q: 未来時刻のファイルは？**  
  A: Activeに入る。PCの時計ずれが疑われる場合は時刻設定を確認。
- **Q: バージョンはどこで見る？**  
  A: `ftime -V` で表示。

## 12. 参考リンク
- 仕様: `docs/SPEC-ja.md`
- 設計: `docs/ARCHITECTURE-ja.md`
- CLI詳細: `docs/CLI-ja.md`
- テスト計画: `docs/TESTPLAN-ja.md`

---

このガイドを読み、実際に3つ以上のコマンドを試してみれば、ftimeの主な使い方を一通り体得できます。日常タスクに組み込んで、直近ファイルの可視化を作業の起点にしてください。 

## 13. コマンド早見表（コピペ用）
| やりたいこと | コマンド | 備考 |
| --- | --- | --- |
| 今日の変更だけざっと見る | `ftime` | Historyは折り畳み |
| 昨日以前も含め全部見る | `ftime -a` | 各バケット20件上限あり |
| dotfileも含めて確認 | `ftime -H` | `.env`, `.gitignore` など |
| dotfile+History全部 | `ftime -a -H` | 情報量多め |
| 非TTYでもTTY書式で保存 | `NO_COLOR=1 FTIME_FORCE_TTY=1 ftime > out.txt` | ログ共有に便利 |
| パスだけ抜き出す | `ftime | cut -f1` | パイプ出力利用 |
| fzfで選んで開く | `ftime | fzf --with-nth=1 | xargs -r code` | VS Code例 |

## 14. ステップバイステップ・チュートリアル（15分想定）
1. **起動確認**: `ftime -V` でバージョンを確認。  
2. **基本表示**: `ftime` を実行し、バケットと相対時間の見た目を確認。  
3. **History展開**: `ftime -a` を試し、`... and N more items` の意味を理解する。  
4. **dotfile表示**: `ftime -H` で `.git` などが現れることを確認。  
5. **パイプ活用**: `ftime | head -n 5` で非TTY出力を体感。  
6. **fzf連携**: `ftime | fzf --with-nth=1 | cut -f1` で任意のファイルパスを取得。  
7. **ログ保存**: `NO_COLOR=1 FTIME_FORCE_TTY=1 ftime -a > /tmp/ftime.log` を実行し、TTY書式のテキストを確認。  
8. **シンボリックリンク確認**: 任意のリンクを作り `ftime` で `name -> target` 表示を確認。  
9. **空ディレクトリ確認**: 空フォルダで `ftime` を実行し `No recent files found` を見る。  
10. **まとめ**: よく使うコマンドをシェルエイリアスに登録。  

## 15. 運用Tips（チームで使う場合）
- **共通のエイリアスを共有**: `.bashrc` や社内ドキュメントに推奨エイリアスを書いておくと新人が迷わない。  
- **CIのログ方針を決める**: 色を入れるか、TTY強制を使うかを統一し、ログフォーマットが揺れないようにする。  
- **スクリーンショットよりテキスト**: 出力はテキストで共有した方が検索しやすい。`NO_COLOR=1` が無難。  
- **ディレクトリ運用ルールと合わせる**: 隠しファイルを多用する文化なら `-H` をデフォルトにするなど、チーム習慣に合わせる。  
- **テストと連動**: 仕様変更時は `docs/TESTPLAN-ja.md` の該当シナリオを更新し、`cargo test` を必ず回す。  

## 16. 誤用しがちなポイントと回避策
- **「何も出ない＝エラー」と決めつける** → 空ディレクトリや隠しファイルのみの可能性。`-H` を試し、終了コードを確認（0なら正常）。  
- **大量HistoryをTTYで追い続ける** → 折り畳みのまま件数だけ見て、詳細はパイプで処理するのが効率的。  
- **色が出ないのに悩む** → `NO_COLOR` の設定や端末のANSI対応を確認。Windows旧環境では無色が正しい動作の場合も。  
- **パスにタブがあると崩れる** → パイプ処理前に `tr` で置換する。  
- **タイムゾーン違いでToday判定がズレる** → CIやコンテナでは `TZ` を明示し、ローカルと揃える。  

## 17. クックブック（用途別ワンライナー集）
- **最近のRustファイルだけ見る**: `ftime | grep '\\.rs\\t'`  
- **ログファイルを時系列で上位10件**: `ftime | grep '\\.log\\t' | head -n 10`  
- **ディレクトリだけ抽出**: `FTIME_FORCE_TTY=1 ftime | grep '/  '`  
- **8日以上前だけを削除候補に列挙**: `ftime | awk -F'\t' '$2 ~ /[0-9]{4}-[0-9]{2}-[0-9]{2}/ {print $1}'`  
- **最新3件をエディタで開く（VS Code例）**: `ftime | head -n 3 | cut -f1 | xargs -r code`  
- **出力をSlackに貼る用テキストで取得**: `NO_COLOR=1 FTIME_FORCE_TTY=1 ftime -a > /tmp/ftime.txt`  

## 18. 学習ロードマップ（ジュニアSE向け）
1. **10分**: 本ガイドの「基本」と「ユースケース」を読む。  
2. **20分**: チュートリアル手順（節14）を手で試す。  
3. **30分**: fzf連携などパイプ操作を自分のプロジェクトで試し、エイリアスを作成。  
4. **45分**: `docs/SPEC-ja.md` を読み、相対時間やバケット条件を理解。  
5. **60分**: `docs/TESTPLAN-ja.md` を眺め、テスト観点を掴む。CIで `cargo test` を回す練習。  
6. **90分以降**: チームの標準手順に組み込み、日次で `ftime` を使う。  

## 19. 付録：出力を読むときのチェック順
1. バケットヘッダが想定順（Active→Today→Week→History）になっているか。  
2. Activeに「未来時刻」が紛れていないか（紛れていたら端末時刻を疑う）。  
3. Historyが折り畳まれている場合、件数が期待どおりか。  
4. シンボリックリンクのターゲット解決が `<unresolved>` になっていないか。  
5. 非TTY出力ならタブ区切り2列になっているか。  

## 20. さらに踏み込むための題材
- **タイムゾーン変更テスト**: `TZ=UTC ftime` とローカルTZで結果を比べる。  
- **大規模ディレクトリ実験**: 一時ディレクトリに1000ファイルを作り、TTY表示の上限とパイプ出力の差を体感。  
- **権限エラー挙動**: `chmod 000 locked` したファイルを含むディレクトリで実行し、スキップされることを確認。  
- **シンボリックリンク表示**: 解決成功と失敗の両方を用意して差を確認。  

## 21. まとめ（再掲）
- 「今すぐ再開したい」→ `ftime`  
- 「昨日まで含めたい」→ `ftime -a`  
- 「隠しも欲しい」→ `ftime -H`  
- 「ログに貼りたい」→ `NO_COLOR=1 FTIME_FORCE_TTY=1 ftime -a > file`  
- 「スクリプトで使う」→ パイプ出力（タブ区切り）を前提に処理  

以上を押さえれば、ジュニアSEでもftimeを日常業務に安全かつ効果的に組み込めます。 
